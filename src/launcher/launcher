#!/usr/bin/env python
import daemon
import datetime
import dhmon
import os
import shlex
import subprocess
import sys
import syslog
import time
import yaml


if len(sys.argv) != 4:
    print '%s: config daemon_id pidfile' % sys.argv[0]
    sys.exit(0)

config = yaml.load(file(sys.argv[1], 'r'))

PERIOD = config['period']
DAEMONS = int(config['number_of_daemons'])
ID = int(sys.argv[2])
OFFSET = (PERIOD / DAEMONS) * ID
PIDFILE = sys.argv[3]

def execute():
    processes = {}
    for script in config['scripts']:
        syslog.syslog(syslog.LOG_DEBUG, 'Running "%s"' % script)
        processes[script] = subprocess.Popen(script, shell=True)

    for cmdline, p in processes.iteritems():
        p.wait()
        if p.returncode != 0:
            syslog.syslog(syslog.LOG_WARNING,
                    'Process "%s" exited with error code %d' % (
                        cmdline, p.returncode))

def new_cycle(jitter):
    execute()

    now = (int(time.time() * 1000) - OFFSET)
    offset = now % PERIOD
    elapsed = offset - jitter
    if offset > int(float(PERIOD) * 0.9):
        syslog.syslog(syslog.LOG_CRIT,
                'Job dispatch took more than 90%% of the period, %d ms spent' % (
                    elapsed, ))
    dhmon.metric('dhmon.%s.launcher.jitter' % config['name'], jitter)
    dhmon.metric('dhmon.%s.elapsed' % config['name'], elapsed)
    return elapsed

def main():
    previous_cycle = 0
    start_up = True
    while True:
        # Calculate our local 'now' with offset for our daemon index.
        now = (int(time.time() * 1000) - OFFSET)

        cycle = now / PERIOD
        jitter = now % PERIOD
        elapsed = 0
        if cycle != previous_cycle and not start_up:
            if jitter > 10000:
                syslog.syslog(syslog.LOG_CRIT,
                        'High jitter in job dispatcher, %d ms behind' % jitter)
            elapsed = new_cycle(jitter)

        time.sleep(float(min(PERIOD - elapsed - jitter, 1000)) / 1000)
        previous_cycle = cycle
        start_up = False

with daemon.DaemonContext():
    with open(PIDFILE, 'w') as pidfile:
        pidfile.write(str(os.getpid()))
        pidfile.close()
    main()
