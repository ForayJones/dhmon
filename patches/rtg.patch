diff --git a/src/common.h b/src/common.h
index cdbd6ac..387ebb0 100644
--- a/src/common.h
+++ b/src/common.h
@@ -50,4 +50,5 @@
 # include <mysql.h>
 #endif
 
+# include <zmq.h>
 #endif /* RTG_COMMON_H */
diff --git a/src/rtg.h b/src/rtg.h
index 43ee188..be0d3df 100644
--- a/src/rtg.h
+++ b/src/rtg.h
@@ -17,7 +17,7 @@
 #endif
 
 /* Constants */
-#define MAX_THREADS 10
+#define MAX_THREADS 50
 #define BUFSIZE 512
 #define BITSINBYTE 8
 #define THIRTYTWO 4294967295ul
@@ -40,6 +40,7 @@
 #define DEFAULT_DB_DB "rtg"
 #define DEFAULT_DB_USER "snmp"
 #define DEFAULT_DB_PASS "rtgdefault"
+#define DEFAULT_ZMQ_URL "tcp://localhost:5555"
 #define DEFAULT_SNMP_VER 1
 #define DEFAULT_SNMP_PORT 161
 
@@ -81,12 +82,20 @@ typedef struct config_struct {
     char dbdb[80];
     char dbuser[80];
     char dbpass[80];
+    char snmp_username[80];
+    char snmp_authpasswd[80];
+    char snmp_privpasswd[80];
+    char zmqurl[80];
     enum debugLevel verbose;
     unsigned short withzeros;
     unsigned short dboff;
+    unsigned short zmqon;
     unsigned short multiple;
     unsigned short snmp_ver;
     unsigned short snmp_port;
+    unsigned short snmp_auth;
+    unsigned short snmp_priv;
+    unsigned short snmp_security_level;
     unsigned short threads;
     float highskewslop;
     float lowskewslop;
diff --git a/src/rtgpoll.c b/src/rtgpoll.c
index 9ffcfc7..85ce833 100644
--- a/src/rtgpoll.c
+++ b/src/rtgpoll.c
@@ -15,6 +15,8 @@ stats_t stats =
 char *target_file = NULL;
 target_t *current = NULL;
 MYSQL mysql;
+void *mq_socket;
+void *mq_context;
 int entries = 0;
 /* dfp is a debug file pointer.  Points to stderr unless debug=level is set */
 FILE *dfp = NULL;
@@ -41,7 +43,7 @@ int main(int argc, char *argv[]) {
     config_defaults(&set);
 
     /* Parse the command-line. */
-    while ((ch = getopt(argc, argv, "c:dhmt:vz")) != EOF)
+    while ((ch = getopt(argc, argv, "c:dhmt:vzZ")) != EOF)
 	switch ((char) ch) {
 	case 'c':
 	    conf_file = optarg;
@@ -49,6 +51,9 @@ int main(int argc, char *argv[]) {
 	case 'd':
 	    set.dboff = TRUE;
 	    break;
+	case 'Z':
+	    set.zmqon = TRUE;
+	    break;
 	case 'h':
 	    usage(argv[0]);
 	    break;
@@ -142,6 +147,15 @@ int main(int argc, char *argv[]) {
 	    exit(-1);
 	}
     }
+    if(set.zmqon) {
+      mq_context = zmq_init(3);
+      mq_socket = zmq_socket(mq_context, ZMQ_PUB);
+      if(zmq_connect(mq_socket, set.zmqurl) != 0) {
+        fprintf(stderr, "Could not connect to ZMQ using URL '%s'\n",
+            set.zmqurl);
+      }
+      printf("Connected to ZMQ using URL '%s'\n", set.zmqurl);
+    }
     if (set.verbose >= HIGH)
 	printf("\nStarting threads.\n");
 
@@ -209,6 +223,11 @@ int main(int argc, char *argv[]) {
     /* Disconnect from the MySQL Database, exit. */
     if (!(set.dboff))
 	rtg_dbdisconnect(&mysql);
+    if (set.zmqon) {
+      zmq_close(mq_socket);
+      zmq_term(mq_context);
+    }
+
     exit(0);
 }
 
@@ -243,7 +262,13 @@ void *sig_handler(void *arg)
             case SIGQUIT:
                 if (set.verbose >= LOW)
                    printf("Quiting: received signal %d.\n", sig_number);
-                rtg_dbdisconnect(&mysql);
+                if (!(set.dboff)) {
+                  rtg_dbdisconnect(&mysql);
+                }
+                if (set.zmqon) {
+                  zmq_close(mq_socket);
+                  zmq_term(mq_context);
+                }
                 unlink(PIDFILE);
                 exit(1);
                 break;
@@ -255,7 +280,7 @@ void *sig_handler(void *arg)
 void usage(char *prog)
 {
     printf("rtgpoll - RTG v%s\n", VERSION);
-    printf("Usage: %s [-dmz] [-vvv] [-c <file>] -t <file>\n", prog);
+    printf("Usage: %s [-dmzZ] [-vvv] [-c <file>] -t <file>\n", prog);
     printf("\nOptions:\n");
     printf("  -c <file>   Specify configuration file\n");
     printf("  -d          Disable database inserts\n");
@@ -263,6 +288,7 @@ void usage(char *prog)
     printf("  -v          Increase verbosity\n");
 	printf("  -m          Allow multiple instances\n");
 	printf("  -z          Database zero delta inserts\n");
+	printf("  -Z          Use ZeroMQ to send samples\n");
     printf("  -h          Help\n");
     exit(-1);
 }
diff --git a/src/rtgsnmp.c b/src/rtgsnmp.c
index 752e235..c1fc926 100644
--- a/src/rtgsnmp.c
+++ b/src/rtgsnmp.c
@@ -23,6 +23,7 @@
 extern target_t *current;
 extern stats_t stats;
 extern MYSQL mysql;
+extern void *mq_socket;
 
 void *poller(void *thread_args)
 {
@@ -63,31 +64,63 @@ void *poller(void *thread_args)
 	if (set.verbose >= DEVELOP)
 	    printf("Thread [%d] done waiting, received go (work cnt: %d)\n", worker->index, crew->work_count);
 
-	if (current != NULL) {
-	    if (set.verbose >= HIGH)
-	      printf("Thread [%d] processing %s %s (%d work units remain in queue)\n", worker->index, current->host, current->objoid, crew->work_count);
-	    snmp_sess_init(&session);
-		if (set.snmp_ver == 2)
-	      session.version = SNMP_VERSION_2c;
-		else
-	      session.version = SNMP_VERSION_1;
-	    session.peername = current->host;
-		session.remote_port = set.snmp_port;
-	    session.community = current->community;
-	    session.community_len = strlen(session.community);
-
-	    sessp = snmp_sess_open(&session);
-	    anOID_len = MAX_OID_LEN;
-	    pdu = snmp_pdu_create(SNMP_MSG_GET);
-	    read_objid(current->objoid, anOID, &anOID_len);
-	    entry = current;
-	    last_value = current->last_value;
-	    init = current->init;
-	    insert_val = 0;
-	    bits = current->bits;
-	    strncpy(storedoid, current->objoid, sizeof(storedoid));
-		current = getNext();
-	}
+  if (current != NULL) {
+    if (set.verbose >= HIGH)
+      printf("Thread [%d] processing %s %s (%d work units remain in queue)\n", worker->index, current->host, current->objoid, crew->work_count);
+    snmp_sess_init(&session);
+    if (set.snmp_ver == 3) {
+      session.version = SNMP_VERSION_3;
+      session.securityName = set.snmp_username;
+      session.securityNameLen = strnlen(set.snmp_username, sizeof(set.snmp_username));
+      session.securityLevel = set.snmp_security_level;
+
+      session.securityAuthProto = set.snmp_auth ? usmHMACSHA1AuthProtocol : usmHMACMD5AuthProtocol;
+      session.securityAuthProtoLen = SNMP_DEFAULT_AUTH_PROTOLEN;
+      session.securityAuthKeyLen = USM_AUTH_KU_LEN;
+
+      session.securityPrivProto = set.snmp_priv ? usmAESPrivProtocol : usmDESPrivProtocol;
+      session.securityPrivProtoLen = SNMP_DEFAULT_AUTH_PROTOLEN;
+      session.securityPrivKeyLen = USM_PRIV_KU_LEN;
+
+      if (session.securityLevel == SNMP_SEC_LEVEL_AUTHNOPRIV ||
+          session.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
+        if (generate_Ku(session.securityAuthProto, session.securityAuthProtoLen,
+              (u_char *) set.snmp_authpasswd, strnlen(set.snmp_authpasswd, sizeof(set.snmp_authpasswd)),
+              session.securityAuthKey, &session.securityAuthKeyLen) != SNMPERR_SUCCESS) {
+          fprintf(stderr, "Error generating Ku from authentication passphrase.\n");
+          exit(1);
+        }
+      }
+      if (session.securityLevel == SNMP_SEC_LEVEL_AUTHPRIV) {
+        if (generate_Ku(session.securityAuthProto, session.securityAuthProtoLen,
+              (u_char *) set.snmp_privpasswd, strnlen(set.snmp_privpasswd, sizeof(set.snmp_privpasswd)),
+              session.securityPrivKey, &session.securityPrivKeyLen) != SNMPERR_SUCCESS) {
+          fprintf(stderr, "Error generating Ku from privacy passphrase.\n");
+          exit(1);
+        }
+      }
+    } else {
+      if (set.snmp_ver == 2)
+          session.version = SNMP_VERSION_2c;
+      else
+        session.version = SNMP_VERSION_1;
+      session.community = current->community;
+      session.community_len = strlen(session.community);
+    }
+    session.peername = current->host;
+    session.remote_port = set.snmp_port;
+    sessp = snmp_sess_open(&session);
+    anOID_len = MAX_OID_LEN;
+    pdu = snmp_pdu_create(SNMP_MSG_GET);
+    read_objid(current->objoid, anOID, &anOID_len);
+    entry = current;
+    last_value = current->last_value;
+    init = current->init;
+    insert_val = 0;
+    bits = current->bits;
+    strncpy(storedoid, current->objoid, sizeof(storedoid));
+    current = getNext();
+  }
 	if (set.verbose >= DEVELOP)
 	    printf("Thread [%d] unlocking (done grabbing current)\n", worker->index);
 	PT_MUTEX_UNLOCK(&crew->mutex);
@@ -207,6 +240,31 @@ void *poller(void *thread_args)
 			PT_MUTEX_UNLOCK(&stats.mutex);
 	    }
 
+		if (set.zmqon) {
+      zmq_msg_t msg;
+      time_t ts;
+      uint64_t *data;
+
+      ts = time(NULL);
+
+      if (zmq_msg_init_size(&msg, sizeof(uint64_t)*3) != 0) {
+        fprintf(stderr, "Failed to create ZMQ message\n");
+        continue;
+      }
+
+      data = zmq_msg_data(&msg);
+      data[0] = (uint64_t)entry->iid;
+      data[1] = (uint64_t)insert_val;
+      data[2] = (uint64_t)ts;
+
+      if (zmq_send(mq_socket, &msg, ZMQ_NOBLOCK) != 0) {
+        fprintf(stderr, "Failed to send to ZMQ, maybe queue is full?\n");
+        continue;
+      }
+
+      zmq_msg_close(&msg);
+		} /* zmqon */
+
 		if (!(set.dboff)) {
 			if ( (insert_val > 0) || (set.withzeros) ) {
 				PT_MUTEX_LOCK(&crew->mutex);
@@ -225,6 +283,7 @@ void *poller(void *thread_args)
 			} /* insert_val > 0 or withzeros */	
 		} /* !dboff */
 
+
 	} /* STAT_SUCCESS */
 
         if (sessp != NULL) {
diff --git a/src/rtgutil.c b/src/rtgutil.c
index 7b84cd3..0dcaf3c 100644
--- a/src/rtgutil.c
+++ b/src/rtgutil.c
@@ -8,6 +8,9 @@
 #include "common.h"
 #include "rtg.h"
 
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+
 extern FILE *dfp;
 
 /* read configuration file to establish local environment */
@@ -37,7 +40,21 @@ int read_rtg_config(char *file, config_t * set)
               else if (!strcasecmp(p1, "DB_Database")) strncpy(set->dbdb, p2, sizeof(set->dbdb));
               else if (!strcasecmp(p1, "DB_User")) strncpy(set->dbuser, p2, sizeof(set->dbuser));
               else if (!strcasecmp(p1, "DB_Pass")) strncpy(set->dbpass, p2, sizeof(set->dbpass));
-
+              else if (!strcasecmp(p1, "ZMQ_Url")) strncpy(set->zmqurl, p2, sizeof(set->zmqurl));
+              else if (!strcasecmp(p1, "SNMP_Username")) strncpy(set->snmp_username, p2, sizeof(set->snmp_username));
+              else if (!strcasecmp(p1, "SNMP_AuthPasswd")) strncpy(set->snmp_authpasswd, p2, sizeof(set->snmp_authpasswd));
+              else if (!strcasecmp(p1, "SNMP_PrivPasswd")) strncpy(set->snmp_privpasswd, p2, sizeof(set->snmp_privpasswd));
+              else if (!strcasecmp(p1, "SNMP_Auth")) set->snmp_auth = (!strcasecmp(p2, "SHA"));
+              else if (!strcasecmp(p1, "SNMP_Priv")) set->snmp_priv = (!strcasecmp(p2, "AES"));
+              else if (!strcasecmp(p1, "SNMP_SecLevel")) {
+                if (!strcasecmp(p2, "authPriv")) {
+                  set->snmp_security_level = SNMP_SEC_LEVEL_AUTHPRIV;
+                } else if (!strcasecmp(p2, "authNoPriv")) {
+                  set->snmp_security_level = SNMP_SEC_LEVEL_AUTHNOPRIV;
+                } else {
+                  set->snmp_security_level = SNMP_SEC_LEVEL_NOAUTH;
+                }
+              }
 /* Long longs not ANSI C.  If OS doesn't support atoll() use default. */
               else if (!strcasecmp(p1, "OutOfRange")) 
 #ifdef HAVE_STRTOLL
@@ -54,7 +71,7 @@ int read_rtg_config(char *file, config_t * set)
            }
         }
 
-        if (set->snmp_ver != 1 && set->snmp_ver != 2) {
+        if (set->snmp_ver != 1 && set->snmp_ver != 2 && set->snmp_ver != 3) {
           fprintf(dfp, "*** Unsupported SNMP version: %d.\n", set->snmp_ver);
           exit(-1);
         }
@@ -110,12 +127,20 @@ void config_defaults(config_t * set)
    strncpy(set->dbdb, DEFAULT_DB_DB, sizeof(set->dbhost));
    strncpy(set->dbuser, DEFAULT_DB_USER, sizeof(set->dbhost));
    strncpy(set->dbpass, DEFAULT_DB_PASS, sizeof(set->dbhost));
+   strncpy(set->zmqurl, DEFAULT_ZMQ_URL, sizeof(set->zmqurl));
    set->dboff = FALSE;
+   set->zmqon = FALSE;
    set->withzeros = FALSE;
    set->verbose = OFF; 
    strncpy(config_paths[0], CONFIG_PATH_1, sizeof(config_paths[0]));
    snprintf(config_paths[1], sizeof(config_paths[1]), "%s/etc/", RTG_HOME);
    strncpy(config_paths[2], CONFIG_PATH_2, sizeof(config_paths[1]));
+   set->snmp_security_level = SNMP_SEC_LEVEL_NOAUTH;
+   set->snmp_auth = 0;
+   set->snmp_priv = 0;
+   memset(set->snmp_username, 0, sizeof(set->snmp_username));
+   memset(set->snmp_authpasswd, 0, sizeof(set->snmp_authpasswd));
+   memset(set->snmp_privpasswd, 0, sizeof(set->snmp_privpasswd));
    return;
 }
 
